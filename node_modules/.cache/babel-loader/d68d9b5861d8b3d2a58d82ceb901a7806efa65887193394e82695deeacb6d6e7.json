{"ast":null,"code":"import { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath as matchPath$1, Router as Router$1 } from 'react-router';\nclass IonRouteInner extends React.PureComponent {\n  render() {\n    return React.createElement(Route, Object.assign({\n      path: this.props.path,\n      exact: this.props.exact,\n      render: this.props.render\n    }, this.props.computedMatch !== undefined ? {\n      computedMatch: this.props.computedMatch\n    } : {}));\n  }\n}\n\n/**\n * @see https://v5.reactrouter.com/web/api/matchPath\n */\nconst matchPath = ({\n  pathname,\n  componentProps\n}) => {\n  const {\n    exact,\n    component\n  } = componentProps;\n  const path = componentProps.path || componentProps.from;\n  /***\n   * The props to match against, they are identical\n   * to the matching props `Route` accepts. It could also be a string\n   * or an array of strings as shortcut for `{ path }`.\n   */\n  const matchProps = {\n    exact,\n    path,\n    component\n  };\n  const match = matchPath$1(pathname, matchProps);\n  if (!match) {\n    return false;\n  }\n  return match;\n};\nclass ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n  createViewItem(outletId, reactElement, routeInfo, page) {\n    const viewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false\n    };\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n    viewItem.routeData = {\n      match: matchPath({\n        pathname: routeInfo.pathname,\n        componentProps: reactElement.props\n      }),\n      childProps: reactElement.props\n    };\n    return viewItem;\n  }\n  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, child => {\n      const viewItem = viewItems.find(v => {\n        return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n    const children = viewItems.map(viewItem => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n      } else {\n        const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n      return clonedChild;\n    });\n    return children;\n  }\n  findViewItemByRouteInfo(routeInfo, outletId, updateMatch) {\n    const {\n      viewItem,\n      match\n    } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    const shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n    if (shouldUpdateMatch && viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n  findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(routeInfo.lastPathname, outletId, mustBeIonRoute);\n    return viewItem;\n  }\n  findViewItemByPathname(pathname, outletId) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n  /**\n   * Returns the matching view item and the match result for a given pathname.\n   */\n  findViewItemByPath(pathname, outletId, mustBeIonRoute) {\n    let viewItem;\n    let match;\n    let viewStack;\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n    return {\n      viewItem,\n      match\n    };\n    function matchView(v) {\n      var _a, _b;\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n      match = matchPath({\n        pathname,\n        componentProps: v.routeData.childProps\n      });\n      if (match) {\n        /**\n         * Even though we have a match from react-router, we do not know if the match\n         * is for this specific view item.\n         *\n         * To validate this, we need to check if the path and url match the view item's route data.\n         */\n        const hasParameter = match.path.includes(':');\n        if (!hasParameter || hasParameter && match.url === ((_b = (_a = v.routeData) === null || _a === void 0 ? void 0 : _a.match) === null || _b === void 0 ? void 0 : _b.url)) {\n          viewItem = v;\n          return true;\n        }\n      }\n      return false;\n    }\n    function matchDefaultRoute(v) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {}\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\nfunction matchComponent$1(node, pathname) {\n  return matchPath({\n    pathname,\n    componentProps: node.props\n  });\n}\nfunction clonePageElement(leavingViewHtml) {\n  let html;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild;\n  }\n  return undefined;\n}\nconst isViewVisible = el => !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\nclass StackManager extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.stackContextValue = {\n      registerIonPage: this.registerIonPage.bind(this),\n      isInOutlet: () => true\n    };\n    this.pendingPageTransition = false;\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n    this.prevProps = undefined;\n    this.skipTransition = false;\n  }\n  componentDidMount() {\n    if (this.clearOutletTimeout) {\n      /**\n       * The clearOutlet integration with React Router is a bit hacky.\n       * It uses a timeout to clear the outlet after a transition.\n       * In React v18, components are mounted and unmounted in development mode\n       * to check for side effects.\n       *\n       * This clearTimeout prevents the outlet from being cleared when the component is re-mounted,\n       * which should only happen in development mode and as a result of a hot reload.\n       */\n      clearTimeout(this.clearOutletTimeout);\n    }\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    const {\n      pathname\n    } = this.props.routeInfo;\n    const {\n      pathname: prevPathname\n    } = prevProps.routeInfo;\n    if (pathname !== prevPathname) {\n      this.prevProps = prevProps;\n      this.handlePageTransition(this.props.routeInfo);\n    } else if (this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n  componentWillUnmount() {\n    this.clearOutletTimeout = this.context.clearOutlet(this.id);\n  }\n  async handlePageTransition(routeInfo) {\n    var _a, _b;\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n      }\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== undefined && !isViewVisible(leavingViewItem.ionPageElement)) {\n          return;\n        }\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n      this.forceUpdate();\n    }\n  }\n  registerIonPage(page, routeInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      const oldPageElement = foundView.ionPageElement;\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n      /**\n       * React 18 will unmount and remount IonPage\n       * elements in development mode when using createRoot.\n       * This can cause duplicate page transitions to occur.\n       */\n      if (oldPageElement === page) {\n        return;\n      }\n    }\n    this.handlePageTransition(routeInfo);\n  }\n  async setupRouterOutlet(routerOutlet) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (!swipeEnabled) {\n        return false;\n      }\n      const {\n        routeInfo\n      } = this.props;\n      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : {\n        pathname: routeInfo.pushedByRoute || ''\n      };\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n      return !!enteringViewItem &&\n      /**\n       * The root url '/' is treated as\n       * the first view item (but is never mounted),\n       * so we do not want to swipe back to the\n       * root url.\n       */\n      enteringViewItem.mount &&\n      /**\n       * When on the first page (whatever view\n       * you land on after the root url) it\n       * is possible for findViewItemByRouteInfo to\n       * return the exact same view you are currently on.\n       * Make sure that we are not swiping back to the same\n       * instances of a view.\n       */\n      enteringViewItem.routeData.match.path !== routeInfo.pathname;\n    };\n    const onStart = async () => {\n      const {\n        routeInfo\n      } = this.props;\n      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : {\n        pathname: routeInfo.pushedByRoute || ''\n      };\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n      /**\n       * When the gesture starts, kick off\n       * a transition that is controlled\n       * via a swipe gesture.\n       */\n      if (enteringViewItem && leavingViewItem) {\n        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n      }\n      return Promise.resolve();\n    };\n    const onEnd = shouldContinue => {\n      if (shouldContinue) {\n        this.skipTransition = true;\n        this.context.goBack();\n      } else {\n        /**\n         * In the event that the swipe\n         * gesture was aborted, we should\n         * re-hide the page that was going to enter.\n         */\n        const {\n          routeInfo\n        } = this.props;\n        const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : {\n          pathname: routeInfo.pushedByRoute || ''\n        };\n        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n        /**\n         * Ionic React has a design defect where it\n         * a) Unmounts the leaving view item when using parameterized routes\n         * b) Considers the current view to be the entering view when using\n         * parameterized routes\n         *\n         * As a result, we should not hide the view item here\n         * as it will cause the current view to be hidden.\n         */\n        if (enteringViewItem !== leavingViewItem && (enteringViewItem === null || enteringViewItem === void 0 ? void 0 : enteringViewItem.ionPageElement) !== undefined) {\n          const {\n            ionPageElement\n          } = enteringViewItem;\n          ionPageElement.setAttribute('aria-hidden', 'true');\n          ionPageElement.classList.add('ion-page-hidden');\n        }\n      }\n    };\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd\n    };\n  }\n  async transitionPage(routeInfo, enteringViewItem, leavingViewItem, direction, progressAnimation = false) {\n    const runCommit = async (enteringEl, leavingEl) => {\n      const skipTransition = this.skipTransition;\n      /**\n       * If the transition was handled\n       * via the swipe to go back gesture,\n       * then we do not want to perform\n       * another transition.\n       *\n       * We skip adding ion-page or ion-page-invisible\n       * because the entering view already exists in the DOM.\n       * If we added the classes, there would be a flicker where\n       * the view would be briefly hidden.\n       */\n      if (skipTransition) {\n        /**\n         * We need to reset skipTransition before\n         * we call routerOutlet.commit otherwise\n         * the transition triggered by the swipe\n         * to go back gesture would reset it. In\n         * that case you would see a duplicate\n         * transition triggered by handlePageTransition\n         * in componentDidUpdate.\n         */\n        this.skipTransition = false;\n      } else {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n      }\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n        direction: directionToUse,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation,\n        animationBuilder: routeInfo.routeAnimation\n      });\n    };\n    const routerOutlet = this.routerOutletElement;\n    const routeInfoFallbackDirection = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n    const directionToUse = direction !== null && direction !== void 0 ? direction : routeInfoFallbackDirection;\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n  render() {\n    const {\n      children\n    } = this.props;\n    const ionRouterOutlet = React.Children.only(children);\n    this.ionRouterOutlet = ionRouterOutlet;\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n    return React.createElement(StackContext.Provider, {\n      value: this.stackContextValue\n    }, React.cloneElement(ionRouterOutlet, {\n      ref: node => {\n        if (ionRouterOutlet.props.setRef) {\n          ionRouterOutlet.props.setRef(node);\n        }\n        if (ionRouterOutlet.props.forwardedRef) {\n          ionRouterOutlet.props.forwardedRef.current = node;\n        }\n        this.routerOutletElement = node;\n        const {\n          ref\n        } = ionRouterOutlet;\n        if (typeof ref === 'function') {\n          ref(node);\n        }\n      }\n    }, components));\n  }\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\nfunction matchRoute(node, routeInfo) {\n  let matchedNode;\n  React.Children.forEach(node, child => {\n    const match = matchPath({\n      pathname: routeInfo.pathname,\n      componentProps: child.props\n    });\n    if (match) {\n      matchedNode = child;\n    }\n  });\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node, child => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\nfunction matchComponent(node, pathname, forceExact) {\n  return matchPath({\n    pathname,\n    componentProps: Object.assign(Object.assign({}, node.props), {\n      exact: forceExact\n    })\n  });\n}\nclass IonRouterInner extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.exitViewFromOtherOutletHandlers = [];\n    this.locationHistory = new LocationHistory();\n    this.viewStack = new ReactRouterViewStack();\n    this.routeMangerContextState = {\n      canGoBack: () => this.locationHistory.canGoBack(),\n      clearOutlet: this.viewStack.clear,\n      findViewItemByPathname: this.viewStack.findViewItemByPathname,\n      getChildrenToRender: this.viewStack.getChildrenToRender,\n      goBack: () => this.handleNavigateBack(),\n      createViewItem: this.viewStack.createViewItem,\n      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: this.viewStack.add,\n      unMountViewItem: this.viewStack.remove\n    };\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search\n    };\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n    this.state = {\n      routeInfo\n    };\n  }\n  handleChangeTab(tab, path, routeOptions) {\n    if (!path) {\n      return;\n    }\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n        routeAction: 'push',\n        routeDirection: 'none'\n      });\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n  handleHistoryChange(location, action) {\n    var _a, _b, _c;\n    let leavingLocationInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n              routeAction: 'pop',\n              routeDirection: 'back'\n            });\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n            tab: this.currentTab\n          };\n        }\n      }\n      let routeInfo;\n      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname\n        });\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = Object.assign(Object.assign({\n          id: generateId('routeInfo')\n        }, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname\n        });\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n          const pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          /**\n           * When replacing routes we should still prefer\n           * any custom direction/animation that the developer\n           * has specified when navigating first instead of relying\n           * on previously used directions/animations.\n           */\n          routeInfo.routeDirection = routeInfo.routeDirection || (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection);\n          routeInfo.routeAnimation = routeInfo.routeAnimation || (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation);\n        }\n        this.locationHistory.add(routeInfo);\n      }\n      this.setState({\n        routeInfo\n      });\n    }\n    this.incomingRouteParams = undefined;\n  }\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab\n    });\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n  handleNavigateBack(defaultHref = '/', routeAnimation) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        /**\n         * This needs to be passed to handleNavigate\n         * otherwise incomingRouteParams.routeAnimation\n         * will be overridden.\n         */\n        const incomingAnimation = routeAnimation || routeInfo.routeAnimation;\n        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: incomingAnimation\n        });\n        if (routeInfo.lastPathname === routeInfo.pushedByRoute || (\n        /**\n         * We need to exclude tab switches/tab\n         * context changes here because tabbed\n         * navigation is not linear, but router.back()\n         * will go back in a linear fashion.\n         */\n        prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '')) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back', incomingAnimation);\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back', routeAnimation);\n      }\n    } else {\n      this.handleNavigate(defaultHref, 'pop', 'back', routeAnimation);\n    }\n  }\n  handleResetTab(tab, originalHref, originalRouteOptions) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = Object.assign({}, routeInfo);\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n        routeAction: 'pop',\n        routeDirection: 'back'\n      });\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n  handleSetCurrentTab(tab) {\n    this.currentTab = tab;\n    const ri = Object.assign({}, this.locationHistory.current());\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n  render() {\n    return React.createElement(RouteManagerContext.Provider, {\n      value: this.routeMangerContextState\n    }, React.createElement(NavManager, {\n      ionRoute: IonRouteInner,\n      ionRedirect: {},\n      stackManager: StackManager,\n      routeInfo: this.state.routeInfo,\n      onNativeBack: this.handleNativeBack,\n      onNavigateBack: this.handleNavigateBack,\n      onNavigate: this.handleNavigate,\n      onSetCurrentTab: this.handleSetCurrentTab,\n      onChangeTab: this.handleChangeTab,\n      onResetTab: this.handleResetTab,\n      locationHistory: this.locationHistory\n    }, this.props.children));\n  }\n}\nconst IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\nclass IonReactRouter extends React.Component {\n  constructor(props) {\n    super(props);\n    const {\n        history\n      } = props,\n      rest = __rest(props, [\"history\"]);\n    this.history = history || createBrowserHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n  render() {\n    const _a = this.props,\n      {\n        children\n      } = _a,\n      props = __rest(_a, [\"children\"]);\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n}\nclass IonReactMemoryRouter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n  render() {\n    const _a = this.props,\n      {\n        children\n      } = _a,\n      props = __rest(_a, [\"children\"]);\n    return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n}\nclass IonReactHashRouter extends React.Component {\n  constructor(props) {\n    super(props);\n    const {\n        history\n      } = props,\n      rest = __rest(props, [\"history\"]);\n    this.history = history || createHashHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n  render() {\n    const _a = this.props,\n      {\n        children\n      } = _a,\n      props = __rest(_a, [\"children\"]);\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n}\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":{"version":3,"names":["IonRouteInner","React","PureComponent","render","createElement","Route","Object","assign","path","props","exact","computedMatch","undefined","matchPath","pathname","componentProps","component","from","matchProps","match","matchPath$1","ReactRouterViewStack","ViewStacks","constructor","createViewItem","bind","findViewItemByRouteInfo","findLeavingViewItemByRouteInfo","getChildrenToRender","findViewItemByPathname","outletId","reactElement","routeInfo","page","viewItem","id","generateId","ionPageElement","mount","ionRoute","type","IonRoute","disableIonPageManagement","routeData","childProps","ionRouterOutlet","viewItems","getViewItemsForOutlet","Children","forEach","children","child","find","v","matchComponent$1","map","clonedChild","ViewLifeCycleManager","key","removeView","remove","cloneElement","updateMatch","findViewItemByPath","shouldUpdateMatch","mustBeIonRoute","lastPathname","viewStack","some","matchView","matchDefaultRoute","getAllViewItems","hasParameter","includes","url","_b","_a","isExact","params","matchComponent","node","clonePageElement","leavingViewHtml","html","outerHTML","document","newEl","innerHTML","style","zIndex","ionBackButton","getElementsByTagName","firstChild","isViewVisible","el","classList","contains","StackManager","stackContextValue","registerIonPage","isInOutlet","pendingPageTransition","transitionPage","handlePageTransition","prevProps","skipTransition","componentDidMount","clearOutletTimeout","clearTimeout","routerOutletElement","setupRouterOutlet","componentDidUpdate","prevPathname","componentWillUnmount","context","clearOutlet","commit","enteringViewItem","leavingViewItem","prevRouteLastPathname","routeAction","routeDirection","routeOptions","unmount","enteringRoute","matchRoute","addViewItem","add","setAttribute","forceUpdate","foundView","oldPageElement","routerOutlet","canStart","config","getConfig","swipeEnabled","get","mode","propsToUse","pushedByRoute","onStart","Promise","resolve","onEnd","shouldContinue","goBack","swipeHandler","direction","progressAnimation","runCommit","enteringEl","leavingEl","duration","directionToUse","showGoBack","animationBuilder","routeAnimation","routeInfoFallbackDirection","newLeavingElement","appendChild","removeChild","only","components","StackContext","Provider","value","ref","setRef","forwardedRef","current","contextType","RouteManagerContext","matchedNode","forceExact","IonRouterInner","exitViewFromOtherOutletHandlers","locationHistory","LocationHistory","routeMangerContextState","canGoBack","clear","handleNavigateBack","unMountViewItem","location","search","handleChangeTab","handleResetTab","handleNativeBack","handleNavigate","registerHistoryListener","handleHistoryChange","handleSetCurrentTab","state","tab","getCurrentRouteInfoForTab","split","incomingRouteParams","history","push","action","leavingLocationInfo","previous","leavingUrl","currentTab","currentRoute","prevInfo","findLastLocation","routerOptions","_c","isPushed","r","lastRoute","currentRouteInfo","currentPushedBy","setState","back","replace","defaultHref","incomingAnimation","originalHref","originalRouteOptions","getFirstRouteInfoForTab","newRouteInfo","ri","update","NavManager","ionRedirect","stackManager","onNativeBack","onNavigateBack","onNavigate","onSetCurrentTab","onChangeTab","onResetTab","IonRouter","withRouter","displayName","IonReactRouter","Component","rest","__rest","createBrowserHistory","listen","locationValue","actionValue","historyListenHandler","cb","Router","IonReactMemoryRouter","Router$1","IonReactHashRouter","createHashHistory"],"sources":["C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\IonRouteInner.tsx","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\utils\\matchPath.ts","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\ReactRouterViewStack.tsx","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\clonePageElement.ts","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\StackManager.tsx","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\IonRouter.tsx","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\IonReactRouter.tsx","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\IonReactMemoryRouter.tsx","C:\\Users\\baaan\\Desktop\\Photogram\\photogramclient\\node_modules\\@ionic\\react-router\\src\\ReactRouter\\IonReactHashRouter.tsx"],"sourcesContent":["import type { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route\n        path={this.props.path}\n        exact={this.props.exact}\n        render={this.props.render}\n        {\n          /**\n           * `computedMatch` is a private API in react-router v5 that\n           * has been removed in v6.\n           *\n           * This needs to be removed when we support v6.\n           *\n           * TODO: FW-647\n           */\n          ...((this.props as any).computedMatch !== undefined\n            ? {\n                computedMatch: (this.props as any).computedMatch,\n              }\n            : {})\n        }\n      />\n    );\n  }\n}\n","import { matchPath as reactRouterMatchPath } from 'react-router';\n\ninterface MatchPathOptions {\n  /**\n   * The pathname to match against.\n   */\n  pathname: string;\n  /**\n   * The props to match against, they are identical to the matching props `Route` accepts.\n   */\n  componentProps: {\n    path?: string;\n    from?: string;\n    component?: any;\n    exact?: boolean;\n  };\n}\n\n/**\n * @see https://v5.reactrouter.com/web/api/matchPath\n */\nexport const matchPath = ({\n  pathname,\n  componentProps,\n}: MatchPathOptions): false | ReturnType<typeof reactRouterMatchPath> => {\n  const { exact, component } = componentProps;\n\n  const path = componentProps.path || componentProps.from;\n  /***\n   * The props to match against, they are identical\n   * to the matching props `Route` accepts. It could also be a string\n   * or an array of strings as shortcut for `{ path }`.\n   */\n  const matchProps = {\n    exact,\n    path,\n    component,\n  };\n\n  const match = reactRouterMatchPath(pathname, matchProps);\n\n  if (!match) {\n    return false;\n  }\n\n  return match;\n};\n","import type { RouteInfo, ViewItem } from '@ionic/react';\nimport { IonRoute, ViewLifeCycleManager, ViewStacks, generateId } from '@ionic/react';\nimport React from 'react';\n\nimport { matchPath } from './utils/matchPath';\n\nexport class ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(outletId: string, reactElement: React.ReactElement, routeInfo: RouteInfo, page?: HTMLElement) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false,\n    };\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match: matchPath({\n        pathname: routeInfo.pathname,\n        componentProps: reactElement.props,\n      }),\n      childProps: reactElement.props,\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find((v) => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map((viewItem) => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, updateMatch?: boolean) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    const shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n    if (shouldUpdateMatch && viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, mustBeIonRoute = true) {\n    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname!, outletId, mustBeIonRoute);\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname: string, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  /**\n   * Returns the matching view item and the match result for a given pathname.\n   */\n  private findViewItemByPath(pathname: string, outletId?: string, mustBeIonRoute?: boolean) {\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n\n      match = matchPath({\n        pathname,\n        componentProps: v.routeData.childProps,\n      });\n\n      if (match) {\n        /**\n         * Even though we have a match from react-router, we do not know if the match\n         * is for this specific view item.\n         *\n         * To validate this, we need to check if the path and url match the view item's route data.\n         */\n        const hasParameter = match.path.includes(':');\n        if (!hasParameter || (hasParameter && match.url === v.routeData?.match?.url)) {\n          viewItem = v;\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string) {\n  return matchPath({\n    pathname,\n    componentProps: node.props,\n  });\n}\n","export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n","import type { RouteInfo, StackContextState, ViewItem } from '@ionic/react';\nimport { RouteManagerContext, StackContext, generateId, getConfig } from '@ionic/react';\nimport React from 'react';\n\nimport { clonePageElement } from './clonePageElement';\nimport { matchPath } from './utils/matchPath';\n\n// TODO(FW-2959): types\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface StackManagerState {}\n\nconst isViewVisible = (el: HTMLElement) =>\n  !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n  prevProps?: StackManagerProps;\n  skipTransition: boolean;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true,\n  };\n\n  private clearOutletTimeout: any;\n  private pendingPageTransition = false;\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n    this.prevProps = undefined;\n    this.skipTransition = false;\n  }\n\n  componentDidMount() {\n    if (this.clearOutletTimeout) {\n      /**\n       * The clearOutlet integration with React Router is a bit hacky.\n       * It uses a timeout to clear the outlet after a transition.\n       * In React v18, components are mounted and unmounted in development mode\n       * to check for side effects.\n       *\n       * This clearTimeout prevents the outlet from being cleared when the component is re-mounted,\n       * which should only happen in development mode and as a result of a hot reload.\n       */\n      clearTimeout(this.clearOutletTimeout);\n    }\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    const { pathname } = this.props.routeInfo;\n    const { pathname: prevPathname } = prevProps.routeInfo;\n\n    if (pathname !== prevPathname) {\n      this.prevProps = prevProps;\n      this.handlePageTransition(this.props.routeInfo);\n    } else if (this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n\n  componentWillUnmount() {\n    this.clearOutletTimeout = this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n      }\n\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if (routeInfo.routeOptions?.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute(this.ionRouterOutlet?.props.children, routeInfo) as React.ReactElement;\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n        if (\n          isViewVisible(enteringViewItem.ionPageElement) &&\n          leavingViewItem !== undefined &&\n          !isViewVisible(leavingViewItem.ionPageElement!)\n        ) {\n          return;\n        }\n\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      const oldPageElement = foundView.ionPageElement;\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n\n      /**\n       * React 18 will unmount and remount IonPage\n       * elements in development mode when using createRoot.\n       * This can cause duplicate page transitions to occur.\n       */\n      if (oldPageElement === page) {\n        return;\n      }\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (!swipeEnabled) {\n        return false;\n      }\n\n      const { routeInfo } = this.props;\n\n      const propsToUse =\n        this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n          ? this.prevProps.routeInfo\n          : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n\n      return (\n        !!enteringViewItem &&\n        /**\n         * The root url '/' is treated as\n         * the first view item (but is never mounted),\n         * so we do not want to swipe back to the\n         * root url.\n         */\n        enteringViewItem.mount &&\n        /**\n         * When on the first page (whatever view\n         * you land on after the root url) it\n         * is possible for findViewItemByRouteInfo to\n         * return the exact same view you are currently on.\n         * Make sure that we are not swiping back to the same\n         * instances of a view.\n         */\n        enteringViewItem.routeData.match.path !== routeInfo.pathname\n      );\n    };\n\n    const onStart = async () => {\n      const { routeInfo } = this.props;\n\n      const propsToUse =\n        this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n          ? this.prevProps.routeInfo\n          : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n      /**\n       * When the gesture starts, kick off\n       * a transition that is controlled\n       * via a swipe gesture.\n       */\n      if (enteringViewItem && leavingViewItem) {\n        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n      }\n\n      return Promise.resolve();\n    };\n    const onEnd = (shouldContinue: boolean) => {\n      if (shouldContinue) {\n        this.skipTransition = true;\n\n        this.context.goBack();\n      } else {\n        /**\n         * In the event that the swipe\n         * gesture was aborted, we should\n         * re-hide the page that was going to enter.\n         */\n        const { routeInfo } = this.props;\n\n        const propsToUse =\n          this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n            ? this.prevProps.routeInfo\n            : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n        /**\n         * Ionic React has a design defect where it\n         * a) Unmounts the leaving view item when using parameterized routes\n         * b) Considers the current view to be the entering view when using\n         * parameterized routes\n         *\n         * As a result, we should not hide the view item here\n         * as it will cause the current view to be hidden.\n         */\n        if (enteringViewItem !== leavingViewItem && enteringViewItem?.ionPageElement !== undefined) {\n          const { ionPageElement } = enteringViewItem;\n          ionPageElement.setAttribute('aria-hidden', 'true');\n          ionPageElement.classList.add('ion-page-hidden');\n        }\n      }\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd,\n    };\n  }\n\n  async transitionPage(\n    routeInfo: RouteInfo,\n    enteringViewItem: ViewItem,\n    leavingViewItem?: ViewItem,\n    direction?: 'forward' | 'back',\n    progressAnimation = false\n  ) {\n    const runCommit = async (enteringEl: HTMLElement, leavingEl?: HTMLElement) => {\n      const skipTransition = this.skipTransition;\n\n      /**\n       * If the transition was handled\n       * via the swipe to go back gesture,\n       * then we do not want to perform\n       * another transition.\n       *\n       * We skip adding ion-page or ion-page-invisible\n       * because the entering view already exists in the DOM.\n       * If we added the classes, there would be a flicker where\n       * the view would be briefly hidden.\n       */\n      if (skipTransition) {\n        /**\n         * We need to reset skipTransition before\n         * we call routerOutlet.commit otherwise\n         * the transition triggered by the swipe\n         * to go back gesture would reset it. In\n         * that case you would see a duplicate\n         * transition triggered by handlePageTransition\n         * in componentDidUpdate.\n         */\n        this.skipTransition = false;\n      } else {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n      }\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n        direction: directionToUse,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation,\n        animationBuilder: routeInfo.routeAnimation,\n      });\n    };\n\n    const routerOutlet = this.routerOutletElement!;\n\n    const routeInfoFallbackDirection =\n      routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n    const directionToUse = direction ?? routeInfoFallbackDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(\n          ionRouterOutlet as any,\n          {\n            ref: (node: HTMLIonRouterOutletElement) => {\n              if (ionRouterOutlet.props.setRef) {\n                ionRouterOutlet.props.setRef(node);\n              }\n              if (ionRouterOutlet.props.forwardedRef) {\n                ionRouterOutlet.props.forwardedRef.current = node;\n              }\n              this.routerOutletElement = node;\n              const { ref } = ionRouterOutlet as any;\n              if (typeof ref === 'function') {\n                ref(node);\n              }\n            },\n          },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const match = matchPath({\n      pathname: routeInfo.pathname,\n      componentProps: child.props,\n    });\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  return matchPath({\n    pathname,\n    componentProps: {\n      ...node.props,\n      exact: forceExact,\n    },\n  });\n}\n","import type {\n  AnimationBuilder,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n} from '@ionic/react';\nimport { LocationHistory, NavManager, RouteManagerContext, generateId, getConfig } from '@ionic/react';\nimport type { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport type { RouteComponentProps } from 'react-router-dom';\nimport { withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string; unmount?: boolean };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (cb: (location: HistoryLocation<any>, action: HistoryAction) => void) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    findViewItemByPathname: this.viewStack.findViewItemByPathname,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove,\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search,\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo,\n    };\n  }\n\n  handleChangeTab(tab: string, path?: string, routeOptions?: any) {\n    if (!path) {\n      return;\n    }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab,\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab,\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab,\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...(this.incomingRouteParams as RouteInfo),\n          lastPathname: leavingLocationInfo.pathname,\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed =\n          this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname,\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo?.pushedByRoute;\n          const pushedByRoute =\n            currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname\n              ? currentPushedBy\n              : routeInfo.pushedByRoute;\n\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo?.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n\n          /**\n           * When replacing routes we should still prefer\n           * any custom direction/animation that the developer\n           * has specified when navigating first instead of relying\n           * on previously used directions/animations.\n           */\n          routeInfo.routeDirection = routeInfo.routeDirection || currentRouteInfo?.routeDirection;\n          routeInfo.routeAnimation = routeInfo.routeAnimation || currentRouteInfo?.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo,\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history as any;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(\n    path: string,\n    routeAction: RouteAction,\n    routeDirection?: RouterDirection,\n    routeAnimation?: AnimationBuilder,\n    routeOptions?: any,\n    tab?: string\n  ) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab,\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        /**\n         * This needs to be passed to handleNavigate\n         * otherwise incomingRouteParams.routeAnimation\n         * will be overridden.\n         */\n        const incomingAnimation = routeAnimation || routeInfo.routeAnimation;\n        this.incomingRouteParams = {\n          ...prevInfo,\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: incomingAnimation,\n        };\n        if (\n          routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          /**\n           * We need to exclude tab switches/tab\n           * context changes here because tabbed\n           * navigation is not linear, but router.back()\n           * will go back in a linear fashion.\n           */\n          (prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '')\n        ) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history as any;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back', incomingAnimation);\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back', routeAnimation);\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back', routeAnimation);\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider value={this.routeMangerContextState}>\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNativeBack={this.handleNativeBack}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n","import type { Action as HistoryAction, History, Location as HistoryLocation } from 'history';\nimport { createBrowserHistory as createHistory } from 'history';\nimport React from 'react';\nimport type { BrowserRouterProps } from 'react-router-dom';\nimport { Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n  history: History;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import type { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport type { MemoryRouterProps } from 'react-router';\nimport { Router } from 'react-router';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import type { Action as HistoryAction, History, Location as HistoryLocation } from 'history';\nimport { createHashHistory as createHistory } from 'history';\nimport React from 'react';\nimport type { BrowserRouterProps } from 'react-router-dom';\nimport { Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n"],"mappings":";;;;;;AAIa,MAAAA,aAAc,SAAQC,KAAK,CAACC,aAA4B;EACnEC,MAAMA,CAAA;IACJ,OACEF,KAAA,CAAAG,aAAA,CAACC,KAAK,EAAAC,MAAA,CAAAC,MAAA;MACJC,IAAI,EAAE,IAAI,CAACC,KAAK,CAACD,IAAI;MACrBE,KAAK,EAAE,IAAI,CAACD,KAAK,CAACC,KAAK;MACvBP,MAAM,EAAE,IAAI,CAACM,KAAK,CAACN;IAAM,CAUpB,EAAE,IAAI,CAACM,KAAa,CAACE,aAAa,KAAKC,SAAS,GAC/C;MACED,aAAa,EAAG,IAAI,CAACF,KAAa,CAACE;IACpC,IACD,EAAE,CAAC,CAET;;AAGP;;ACXD;;AAEG;AACI,MAAME,SAAS,GAAGA,CAAC;EACxBC,QAAQ;EACRC;AAAc,CACG,KAAqD;EACtE,MAAM;IAAEL,KAAK;IAAEM;EAAS,CAAE,GAAGD,cAAc;EAE3C,MAAMP,IAAI,GAAGO,cAAc,CAACP,IAAI,IAAIO,cAAc,CAACE,IAAI;EACvD;;;;AAIG;EACH,MAAMC,UAAU,GAAG;IACjBR,KAAK;IACLF,IAAI;IACJQ;GACD;EAED,MAAMG,KAAK,GAAGC,WAAoB,CAACN,QAAQ,EAAEI,UAAU,CAAC;EAExD,IAAI,CAACC,KAAK,EAAE;IACV,OAAO,KAAK;EACb;EAED,OAAOA,KAAK;AACd,CAAC;ACxCK,MAAOE,oBAAqB,SAAQC,UAAU;EAClDC,YAAA;IACE,KAAK,EAAE;IACP,IAAI,CAACC,cAAc,GAAG,IAAI,CAACA,cAAc,CAACC,IAAI,CAAC,IAAI,CAAC;IACpD,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACA,uBAAuB,CAACD,IAAI,CAAC,IAAI,CAAC;IACtE,IAAI,CAACE,8BAA8B,GAAG,IAAI,CAACA,8BAA8B,CAACF,IAAI,CAAC,IAAI,CAAC;IACpF,IAAI,CAACG,mBAAmB,GAAG,IAAI,CAACA,mBAAmB,CAACH,IAAI,CAAC,IAAI,CAAC;IAC9D,IAAI,CAACI,sBAAsB,GAAG,IAAI,CAACA,sBAAsB,CAACJ,IAAI,CAAC,IAAI,CAAC;;EAGtED,cAAcA,CAACM,QAAgB,EAAEC,YAAgC,EAAEC,SAAoB,EAAEC,IAAkB;IACzG,MAAMC,QAAQ,GAAa;MACzBC,EAAE,EAAEC,UAAU,CAAC,UAAU,CAAC;MAC1BN,QAAQ;MACRO,cAAc,EAAEJ,IAAI;MACpBF,YAAY;MACZO,KAAK,EAAE,IAAI;MACXC,QAAQ,EAAE;KACX;IAED,IAAIR,YAAY,CAACS,IAAI,KAAKC,QAAQ,EAAE;MAClCP,QAAQ,CAACK,QAAQ,GAAG,IAAI;MACxBL,QAAQ,CAACQ,wBAAwB,GAAGX,YAAY,CAACtB,KAAK,CAACiC,wBAAwB;IAChF;IAEDR,QAAQ,CAACS,SAAS,GAAG;MACnBxB,KAAK,EAAEN,SAAS,CAAC;QACfC,QAAQ,EAAEkB,SAAS,CAAClB,QAAQ;QAC5BC,cAAc,EAAEgB,YAAY,CAACtB;OAC9B,CAAC;MACFmC,UAAU,EAAEb,YAAY,CAACtB;KAC1B;IAED,OAAOyB,QAAQ;;EAGjBN,mBAAmBA,CAACE,QAAgB,EAAEe,eAAmC,EAAEb,SAAoB;IAC7F,MAAMc,SAAS,GAAG,IAAI,CAACC,qBAAqB,CAACjB,QAAQ,CAAC;;IAGtD7B,KAAK,CAAC+C,QAAQ,CAACC,OAAO,CAACJ,eAAe,CAACpC,KAAK,CAACyC,QAAQ,EAAGC,KAAyB,IAAI;MACnF,MAAMjB,QAAQ,GAAGY,SAAS,CAACM,IAAI,CAAEC,CAAC,IAAI;QACpC,OAAOC,gBAAc,CAACH,KAAK,EAAEE,CAAC,CAACV,SAAS,CAACC,UAAU,CAACpC,IAAI,IAAI6C,CAAC,CAACV,SAAS,CAACC,UAAU,CAAC3B,IAAI,CAAC;MAC1F,CAAC,CAAC;MACF,IAAIiB,QAAQ,EAAE;QACZA,QAAQ,CAACH,YAAY,GAAGoB,KAAK;MAC9B;IACH,CAAC,CAAC;IAEF,MAAMD,QAAQ,GAAGJ,SAAS,CAACS,GAAG,CAAErB,QAAQ,IAAI;MAC1C,IAAIsB,WAAW;MACf,IAAItB,QAAQ,CAACK,QAAQ,IAAI,CAACL,QAAQ,CAACQ,wBAAwB,EAAE;QAC3Dc,WAAW,GACTvD,KAAA,CAAAG,aAAA,CAACqD,oBAAoB;UACnBC,GAAG,EAAE,QAAQxB,QAAQ,CAACC,EAAI;UAC1BG,KAAK,EAAEJ,QAAQ,CAACI,KAAK;UACrBqB,UAAU,EAAEA,CAAA,KAAM,IAAI,CAACC,MAAM,CAAC1B,QAAQ;QAAC,GAEtCjC,KAAK,CAAC4D,YAAY,CAAC3B,QAAQ,CAACH,YAAY,EAAE;UACzCpB,aAAa,EAAEuB,QAAQ,CAACS,SAAS,CAACxB;SACnC,CAAC,CAEL;MACF,OAAM;QACL,MAAMA,KAAK,GAAGmC,gBAAc,CAACpB,QAAQ,CAACH,YAAY,EAAEC,SAAS,CAAClB,QAAQ,CAAC;QACvE0C,WAAW,GACTvD,KAAA,CAAAG,aAAA,CAACqD,oBAAoB;UACnBC,GAAG,EAAE,QAAQxB,QAAQ,CAACC,EAAI;UAC1BG,KAAK,EAAEJ,QAAQ,CAACI,KAAK;UACrBqB,UAAU,EAAEA,CAAA,KAAM,IAAI,CAACC,MAAM,CAAC1B,QAAQ;QAAC,GAEtCjC,KAAK,CAAC4D,YAAY,CAAC3B,QAAQ,CAACH,YAAY,EAAE;UACzCpB,aAAa,EAAEuB,QAAQ,CAACS,SAAS,CAACxB;SACnC,CAAC,CAEL;QAED,IAAI,CAACA,KAAK,IAAIe,QAAQ,CAACS,SAAS,CAACxB,KAAK,EAAE;UACtCe,QAAQ,CAACS,SAAS,CAACxB,KAAK,GAAGP,SAAS;UACpCsB,QAAQ,CAACI,KAAK,GAAG,KAAK;QACvB;MACF;MAED,OAAOkB,WAAW;IACpB,CAAC,CAAC;IACF,OAAON,QAAQ;;EAGjBxB,uBAAuBA,CAACM,SAAoB,EAAEF,QAAiB,EAAEgC,WAAqB;IACpF,MAAM;MAAE5B,QAAQ;MAAEf;IAAK,CAAE,GAAG,IAAI,CAAC4C,kBAAkB,CAAC/B,SAAS,CAAClB,QAAQ,EAAEgB,QAAQ,CAAC;IACjF,MAAMkC,iBAAiB,GAAGF,WAAW,KAAKlD,SAAS,IAAIkD,WAAW,KAAK,IAAI;IAC3E,IAAIE,iBAAiB,IAAI9B,QAAQ,IAAIf,KAAK,EAAE;MAC1Ce,QAAQ,CAACS,SAAS,CAACxB,KAAK,GAAGA,KAAK;IACjC;IACD,OAAOe,QAAQ;;EAGjBP,8BAA8BA,CAACK,SAAoB,EAAEF,QAAiB,EAAEmC,cAAc,GAAG,IAAI;IAC3F,MAAM;MAAE/B;IAAQ,CAAE,GAAG,IAAI,CAAC6B,kBAAkB,CAAC/B,SAAS,CAACkC,YAAa,EAAEpC,QAAQ,EAAEmC,cAAc,CAAC;IAC/F,OAAO/B,QAAQ;;EAGjBL,sBAAsBA,CAACf,QAAgB,EAAEgB,QAAiB;IACxD,MAAM;MAAEI;IAAQ,CAAE,GAAG,IAAI,CAAC6B,kBAAkB,CAACjD,QAAQ,EAAEgB,QAAQ,CAAC;IAChE,OAAOI,QAAQ;;EAGjB;;AAEG;EACK6B,kBAAkBA,CAACjD,QAAgB,EAAEgB,QAAiB,EAAEmC,cAAwB;IACtF,IAAI/B,QAA8B;IAClC,IAAIf,KAA+C;IACnD,IAAIgD,SAAqB;IAEzB,IAAIrC,QAAQ,EAAE;MACZqC,SAAS,GAAG,IAAI,CAACpB,qBAAqB,CAACjB,QAAQ,CAAC;MAChDqC,SAAS,CAACC,IAAI,CAACC,SAAS,CAAC;MACzB,IAAI,CAACnC,QAAQ,EAAE;QACbiC,SAAS,CAACC,IAAI,CAACE,iBAAiB,CAAC;MAClC;IACF,OAAM;MACL,MAAMxB,SAAS,GAAG,IAAI,CAACyB,eAAe,EAAE;MACxCzB,SAAS,CAACsB,IAAI,CAACC,SAAS,CAAC;MACzB,IAAI,CAACnC,QAAQ,EAAE;QACbY,SAAS,CAACsB,IAAI,CAACE,iBAAiB,CAAC;MAClC;IACF;IAED,OAAO;MAAEpC,QAAQ;MAAEf;IAAK,CAAE;IAE1B,SAASkD,SAASA,CAAChB,CAAW;;MAC5B,IAAIY,cAAc,IAAI,CAACZ,CAAC,CAACd,QAAQ,EAAE;QACjC,OAAO,KAAK;MACb;MAEDpB,KAAK,GAAGN,SAAS,CAAC;QAChBC,QAAQ;QACRC,cAAc,EAAEsC,CAAC,CAACV,SAAS,CAACC;MAC7B,EAAC;MAEF,IAAIzB,KAAK,EAAE;QACT;;;;;AAKG;QACH,MAAMqD,YAAY,GAAGrD,KAAK,CAACX,IAAI,CAACiE,QAAQ,CAAC,GAAG,CAAC;QAC7C,IAAI,CAACD,YAAY,IAAKA,YAAY,IAAIrD,KAAK,CAACuD,GAAG,MAAK,CAAAC,EAAA,IAAAC,EAAA,GAAAvB,CAAC,CAACV,SAAS,cAAAiC,EAAA,uBAAAA,EAAA,CAAEzD,KAAK,MAAE,QAAAwD,EAAA,uBAAAA,EAAA,CAAAD,GAAG,CAAC,EAAE;UAC5ExC,QAAQ,GAAGmB,CAAC;UACZ,OAAO,IAAI;QACZ;MACF;MACD,OAAO,KAAK;;IAGd,SAASiB,iBAAiBA,CAACjB,CAAW;;MAEpC,IAAI,CAACA,CAAC,CAACV,SAAS,CAACC,UAAU,CAACpC,IAAI,IAAI,CAAC6C,CAAC,CAACV,SAAS,CAACC,UAAU,CAAC3B,IAAI,EAAE;QAChEE,KAAK,GAAG;UACNX,IAAI,EAAEM,QAAQ;UACd4D,GAAG,EAAE5D,QAAQ;UACb+D,OAAO,EAAE,IAAI;UACbC,MAAM,EAAE;SACT;QACD5C,QAAQ,GAAGmB,CAAC;QACZ,OAAO,IAAI;MACZ;MACD,OAAO,KAAK;;;AAGjB;AAED,SAASC,gBAAcyB,CAACC,IAAwB,EAAElE,QAAgB;EAChE,OAAOD,SAAS,CAAC;IACfC,QAAQ;IACRC,cAAc,EAAEiE,IAAI,CAACvE;EACtB,EAAC;AACJ;ACzLM,SAAUwE,gBAAgBA,CAACC,eAAqC;EACpE,IAAIC,IAAY;EAChB,IAAI,OAAOD,eAAe,KAAK,QAAQ,EAAE;IACvCC,IAAI,GAAGD,eAAe;EACvB,OAAM;IACLC,IAAI,GAAGD,eAAe,CAACE,SAAS;EACjC;EACD,IAAIC,QAAQ,EAAE;IACZ,MAAMC,KAAK,GAAGD,QAAQ,CAACjF,aAAa,CAAC,KAAK,CAAC;IAC3CkF,KAAK,CAACC,SAAS,GAAGJ,IAAI;IACtBG,KAAK,CAACE,KAAK,CAACC,MAAM,GAAG,EAAE;;IAEvB,MAAMC,aAAa,GAAGJ,KAAK,CAACK,oBAAoB,CAAC,iBAAiB,CAAC;IACnE,IAAID,aAAa,CAAC,CAAC,CAAC,EAAE;MACpBA,aAAa,CAAC,CAAC,CAAC,CAAC9B,MAAM,EAAE;IAC1B;IACD,OAAO0B,KAAK,CAACM,UAAyB;EACvC;EACD,OAAOhF,SAAS;AAClB;ACHA,MAAMiF,aAAa,GAAIC,EAAe,IACpC,CAACA,EAAE,CAACC,SAAS,CAACC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAACF,EAAE,CAACC,SAAS,CAACC,QAAQ,CAAC,iBAAiB,CAAC;AAE9E,MAAAC,YAAa,SAAQhG,KAAK,CAACC,aAAmD;EAgBzFqB,YAAYd,KAAwB;IAClC,KAAK,CAACA,KAAK,CAAC;IATd,KAAAyF,iBAAiB,GAAsB;MACrCC,eAAe,EAAE,IAAI,CAACA,eAAe,CAAC1E,IAAI,CAAC,IAAI,CAAC;MAChD2E,UAAU,EAAEA,CAAA,KAAM;KACnB;IAGO,IAAqB,CAAAC,qBAAA,GAAG,KAAK;IAInC,IAAI,CAACF,eAAe,GAAG,IAAI,CAACA,eAAe,CAAC1E,IAAI,CAAC,IAAI,CAAC;IACtD,IAAI,CAAC6E,cAAc,GAAG,IAAI,CAACA,cAAc,CAAC7E,IAAI,CAAC,IAAI,CAAC;IACpD,IAAI,CAAC8E,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAAC9E,IAAI,CAAC,IAAI,CAAC;IAChE,IAAI,CAACU,EAAE,GAAGC,UAAU,CAAC,cAAc,CAAC;IACpC,IAAI,CAACoE,SAAS,GAAG5F,SAAS;IAC1B,IAAI,CAAC6F,cAAc,GAAG,KAAK;;EAG7BC,iBAAiBA,CAAA;IACf,IAAI,IAAI,CAACC,kBAAkB,EAAE;MAC3B;;;;;;;;AAQG;MACHC,YAAY,CAAC,IAAI,CAACD,kBAAkB,CAAC;IACtC;IACD,IAAI,IAAI,CAACE,mBAAmB,EAAE;MAC5B,IAAI,CAACC,iBAAiB,CAAC,IAAI,CAACD,mBAAmB,CAAC;MAChD,IAAI,CAACN,oBAAoB,CAAC,IAAI,CAAC9F,KAAK,CAACuB,SAAS,CAAC;IAChD;;EAGH+E,kBAAkBA,CAACP,SAA4B;IAC7C,MAAM;MAAE1F;IAAQ,CAAE,GAAG,IAAI,CAACL,KAAK,CAACuB,SAAS;IACzC,MAAM;MAAElB,QAAQ,EAAEkG;IAAY,CAAE,GAAGR,SAAS,CAACxE,SAAS;IAEtD,IAAIlB,QAAQ,KAAKkG,YAAY,EAAE;MAC7B,IAAI,CAACR,SAAS,GAAGA,SAAS;MAC1B,IAAI,CAACD,oBAAoB,CAAC,IAAI,CAAC9F,KAAK,CAACuB,SAAS,CAAC;IAChD,OAAM,IAAI,IAAI,CAACqE,qBAAqB,EAAE;MACrC,IAAI,CAACE,oBAAoB,CAAC,IAAI,CAAC9F,KAAK,CAACuB,SAAS,CAAC;MAC/C,IAAI,CAACqE,qBAAqB,GAAG,KAAK;IACnC;;EAGHY,oBAAoBA,CAAA;IAClB,IAAI,CAACN,kBAAkB,GAAG,IAAI,CAACO,OAAO,CAACC,WAAW,CAAC,IAAI,CAAChF,EAAE,CAAC;;EAG7D,MAAMoE,oBAAoBA,CAACvE,SAAoB;;IAC7C,IAAI,CAAC,IAAI,CAAC6E,mBAAmB,IAAI,CAAC,IAAI,CAACA,mBAAmB,CAACO,MAAM,EAAE;MACjE;;;;;;AAMG;MACH,IAAI,CAACf,qBAAqB,GAAG,IAAI;IAClC,OAAM;MACL,IAAIgB,gBAAgB,GAAG,IAAI,CAACH,OAAO,CAACxF,uBAAuB,CAACM,SAAS,EAAE,IAAI,CAACG,EAAE,CAAC;MAC/E,IAAImF,eAAe,GAAG,IAAI,CAACJ,OAAO,CAACvF,8BAA8B,CAACK,SAAS,EAAE,IAAI,CAACG,EAAE,CAAC;MAErF,IAAI,CAACmF,eAAe,IAAItF,SAAS,CAACuF,qBAAqB,EAAE;QACvDD,eAAe,GAAG,IAAI,CAACJ,OAAO,CAACrF,sBAAsB,CAACG,SAAS,CAACuF,qBAAqB,EAAE,IAAI,CAACpF,EAAE,CAAC;MAChG;;MAGD,IAAImF,eAAe,EAAE;QACnB,IAAItF,SAAS,CAACwF,WAAW,KAAK,SAAS,EAAE;UACvCF,eAAe,CAAChF,KAAK,GAAG,KAAK;QAC9B,OAAM,IAAI,EAAEN,SAAS,CAACwF,WAAW,KAAK,MAAM,IAAIxF,SAAS,CAACyF,cAAc,KAAK,SAAS,CAAC,EAAE;UACxF,IAAIzF,SAAS,CAACyF,cAAc,KAAK,MAAM,IAAIJ,gBAAgB,KAAKC,eAAe,EAAE;YAC/EA,eAAe,CAAChF,KAAK,GAAG,KAAK;UAC9B;QACF,OAAM,IAAI,CAAAsC,EAAA,GAAA5C,SAAS,CAAC0F,YAAY,cAAA9C,EAAA,uBAAAA,EAAA,CAAE+C,OAAO,EAAE;UAC1CL,eAAe,CAAChF,KAAK,GAAG,KAAK;QAC9B;MACF;MAED,MAAMsF,aAAa,GAAGC,UAAU,CAAC,CAAAlD,EAAA,OAAI,CAAC9B,eAAe,cAAA8B,EAAA,uBAAAA,EAAA,CAAElE,KAAK,CAACyC,QAAQ,EAAElB,SAAS,CAAuB;MAEvG,IAAIqF,gBAAgB,EAAE;QACpBA,gBAAgB,CAACtF,YAAY,GAAG6F,aAAa;MAC9C,OAAM,IAAIA,aAAa,EAAE;QACxBP,gBAAgB,GAAG,IAAI,CAACH,OAAO,CAAC1F,cAAc,CAAC,IAAI,CAACW,EAAE,EAAEyF,aAAa,EAAE5F,SAAS,CAAC;QACjF,IAAI,CAACkF,OAAO,CAACY,WAAW,CAACT,gBAAgB,CAAC;MAC3C;MAED,IAAIA,gBAAgB,IAAIA,gBAAgB,CAAChF,cAAc,EAAE;QACvD;;;AAGG;QACH,IAAIgF,gBAAgB,KAAKC,eAAe,EAAE;UACxC;;;;;;;AAOG;UACH,IAAID,gBAAgB,CAAC1E,SAAS,CAACxB,KAAK,CAACuD,GAAG,KAAK1C,SAAS,CAAClB,QAAQ,EAAE;YAC/D;UACD;QACF;QAED;;;;AAIG;QACH,IAAI,CAACwG,eAAe,IAAI,IAAI,CAAC7G,KAAK,CAACuB,SAAS,CAACuF,qBAAqB,EAAE;UAClED,eAAe,GAAG,IAAI,CAACJ,OAAO,CAACrF,sBAAsB,CAAC,IAAI,CAACpB,KAAK,CAACuB,SAAS,CAACuF,qBAAqB,EAAE,IAAI,CAACpF,EAAE,CAAC;QAC3G;QAED;;AAEG;QACH,IACE0D,aAAa,CAACwB,gBAAgB,CAAChF,cAAc,CAAC,IAC9CiF,eAAe,KAAK1G,SAAS,IAC7B,CAACiF,aAAa,CAACyB,eAAe,CAACjF,cAAe,CAAC,EAC/C;UACA;QACD;QAED;;;;;;;;;;;;;;AAcG;QACH,IAAI,CAACiE,cAAc,CAACtE,SAAS,EAAEqF,gBAAgB,EAAEC,eAAe,CAAC;MAClE,OAAM,IAAIA,eAAe,IAAI,CAACM,aAAa,IAAI,CAACP,gBAAgB,EAAE;;;;;QAKjE,IAAIC,eAAe,CAACjF,cAAc,EAAE;UAClCiF,eAAe,CAACjF,cAAc,CAAC0D,SAAS,CAACgC,GAAG,CAAC,iBAAiB,CAAC;UAC/DT,eAAe,CAACjF,cAAc,CAAC2F,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;QACnE;;MAEF;MAED,IAAI,CAACC,WAAW,EAAE;IACnB;;EAGH9B,eAAeA,CAAClE,IAAiB,EAAED,SAAoB;IACrD,MAAMkG,SAAS,GAAG,IAAI,CAAChB,OAAO,CAACxF,uBAAuB,CAACM,SAAS,EAAE,IAAI,CAACG,EAAE,CAAC;IAC1E,IAAI+F,SAAS,EAAE;MACb,MAAMC,cAAc,GAAGD,SAAS,CAAC7F,cAAc;MAC/C6F,SAAS,CAAC7F,cAAc,GAAGJ,IAAI;MAC/BiG,SAAS,CAAC3F,QAAQ,GAAG,IAAI;MAEzB;;;;AAIG;MACH,IAAI4F,cAAc,KAAKlG,IAAI,EAAE;QAC3B;MACD;IACF;IACD,IAAI,CAACsE,oBAAoB,CAACvE,SAAS,CAAC;;EAGtC,MAAM8E,iBAAiBA,CAACsB,YAAwC;IAC9D,MAAMC,QAAQ,GAAGA,CAAA,KAAK;MACpB,MAAMC,MAAM,GAAGC,SAAS,EAAE;MAC1B,MAAMC,YAAY,GAAGF,MAAM,IAAIA,MAAM,CAACG,GAAG,CAAC,kBAAkB,EAAEL,YAAY,CAACM,IAAI,KAAK,KAAK,CAAC;MAC1F,IAAI,CAACF,YAAY,EAAE;QACjB,OAAO,KAAK;MACb;MAED,MAAM;QAAExG;MAAS,CAAE,GAAG,IAAI,CAACvB,KAAK;MAEhC,MAAMkI,UAAU,GACd,IAAI,CAACnC,SAAS,IAAI,IAAI,CAACA,SAAS,CAACxE,SAAS,CAAClB,QAAQ,KAAKkB,SAAS,CAAC4G,aAAa,GAC3E,IAAI,CAACpC,SAAS,CAACxE,SAAS,GACvB;QAAElB,QAAQ,EAAEkB,SAAS,CAAC4G,aAAa,IAAI;MAAE,CAAU;MAC1D,MAAMvB,gBAAgB,GAAG,IAAI,CAACH,OAAO,CAACxF,uBAAuB,CAACiH,UAAU,EAAE,IAAI,CAACxG,EAAE,EAAE,KAAK,CAAC;MAEzF,OACE,CAAC,CAACkF,gBAAgB;MAClB;;;;;AAKG;MACHA,gBAAgB,CAAC/E,KAAK;MACtB;;;;;;;AAOG;MACH+E,gBAAgB,CAAC1E,SAAS,CAACxB,KAAK,CAACX,IAAI,KAAKwB,SAAS,CAAClB,QAAQ;IAEhE,CAAC;IAED,MAAM+H,OAAO,GAAG,MAAAA,CAAA,KAAW;MACzB,MAAM;QAAE7G;MAAS,CAAE,GAAG,IAAI,CAACvB,KAAK;MAEhC,MAAMkI,UAAU,GACd,IAAI,CAACnC,SAAS,IAAI,IAAI,CAACA,SAAS,CAACxE,SAAS,CAAClB,QAAQ,KAAKkB,SAAS,CAAC4G,aAAa,GAC3E,IAAI,CAACpC,SAAS,CAACxE,SAAS,GACvB;QAAElB,QAAQ,EAAEkB,SAAS,CAAC4G,aAAa,IAAI;MAAE,CAAU;MAC1D,MAAMvB,gBAAgB,GAAG,IAAI,CAACH,OAAO,CAACxF,uBAAuB,CAACiH,UAAU,EAAE,IAAI,CAACxG,EAAE,EAAE,KAAK,CAAC;MACzF,MAAMmF,eAAe,GAAG,IAAI,CAACJ,OAAO,CAACxF,uBAAuB,CAACM,SAAS,EAAE,IAAI,CAACG,EAAE,EAAE,KAAK,CAAC;MAEvF;;;;AAIG;MACH,IAAIkF,gBAAgB,IAAIC,eAAe,EAAE;QACvC,MAAM,IAAI,CAAChB,cAAc,CAACtE,SAAS,EAAEqF,gBAAgB,EAAEC,eAAe,EAAE,MAAM,EAAE,IAAI,CAAC;MACtF;MAED,OAAOwB,OAAO,CAACC,OAAO,EAAE;IAC1B,CAAC;IACD,MAAMC,KAAK,GAAIC,cAAuB,IAAI;MACxC,IAAIA,cAAc,EAAE;QAClB,IAAI,CAACxC,cAAc,GAAG,IAAI;QAE1B,IAAI,CAACS,OAAO,CAACgC,MAAM,EAAE;MACtB,OAAM;QACL;;;;AAIG;QACH,MAAM;UAAElH;QAAS,CAAE,GAAG,IAAI,CAACvB,KAAK;QAEhC,MAAMkI,UAAU,GACd,IAAI,CAACnC,SAAS,IAAI,IAAI,CAACA,SAAS,CAACxE,SAAS,CAAClB,QAAQ,KAAKkB,SAAS,CAAC4G,aAAa,GAC3E,IAAI,CAACpC,SAAS,CAACxE,SAAS,GACvB;UAAElB,QAAQ,EAAEkB,SAAS,CAAC4G,aAAa,IAAI;QAAE,CAAU;QAC1D,MAAMvB,gBAAgB,GAAG,IAAI,CAACH,OAAO,CAACxF,uBAAuB,CAACiH,UAAU,EAAE,IAAI,CAACxG,EAAE,EAAE,KAAK,CAAC;QACzF,MAAMmF,eAAe,GAAG,IAAI,CAACJ,OAAO,CAACxF,uBAAuB,CAACM,SAAS,EAAE,IAAI,CAACG,EAAE,EAAE,KAAK,CAAC;QAEvF;;;;;;;;AAQG;QACH,IAAIkF,gBAAgB,KAAKC,eAAe,IAAI,CAAAD,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEhF,cAAc,MAAKzB,SAAS,EAAE;UAC1F,MAAM;YAAEyB;UAAc,CAAE,GAAGgF,gBAAgB;UAC3ChF,cAAc,CAAC2F,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;UAClD3F,cAAc,CAAC0D,SAAS,CAACgC,GAAG,CAAC,iBAAiB,CAAC;QAChD;MACF;IACH,CAAC;IAEDK,YAAY,CAACe,YAAY,GAAG;MAC1Bd,QAAQ;MACRQ,OAAO;MACPG;KACD;;EAGH,MAAM1C,cAAcA,CAClBtE,SAAoB,EACpBqF,gBAA0B,EAC1BC,eAA0B,EAC1B8B,SAA8B,EAC9BC,iBAAiB,GAAG,KAAK;IAEzB,MAAMC,SAAS,GAAG,MAAAA,CAAOC,UAAuB,EAAEC,SAAuB,KAAI;MAC3E,MAAM/C,cAAc,GAAG,IAAI,CAACA,cAAc;MAE1C;;;;;;;;;;AAUG;MACH,IAAIA,cAAc,EAAE;QAClB;;;;;;;;AAQG;QACH,IAAI,CAACA,cAAc,GAAG,KAAK;MAC5B,OAAM;QACL8C,UAAU,CAACxD,SAAS,CAACgC,GAAG,CAAC,UAAU,CAAC;QACpCwB,UAAU,CAACxD,SAAS,CAACgC,GAAG,CAAC,oBAAoB,CAAC;MAC/C;MAED,MAAMK,YAAY,CAAChB,MAAM,CAACmC,UAAU,EAAEC,SAAS,EAAE;QAC/CC,QAAQ,EAAEhD,cAAc,IAAIiD,cAAc,KAAK9I,SAAS,GAAG,CAAC,GAAGA,SAAS;QACxEwI,SAAS,EAAEM,cAAc;QACzBC,UAAU,EAAE,CAAC,CAAC3H,SAAS,CAAC4G,aAAa;QACrCS,iBAAiB;QACjBO,gBAAgB,EAAE5H,SAAS,CAAC6H;MAC7B,EAAC;IACJ,CAAC;IAED,MAAMzB,YAAY,GAAG,IAAI,CAACvB,mBAAoB;IAE9C,MAAMiD,0BAA0B,GAC9B9H,SAAS,CAACyF,cAAc,KAAK,MAAM,IAAIzF,SAAS,CAACyF,cAAc,KAAK,MAAM,GAAG7G,SAAS,GAAGoB,SAAS,CAACyF,cAAc;IACnH,MAAMiC,cAAc,GAAGN,SAAS,aAATA,SAAS,KAAT,SAAAA,SAAS,GAAIU,0BAA0B;IAE9D,IAAIzC,gBAAgB,IAAIA,gBAAgB,CAAChF,cAAc,IAAI,IAAI,CAACwE,mBAAmB,EAAE;MACnF,IAAIS,eAAe,IAAIA,eAAe,CAACjF,cAAc,IAAIgF,gBAAgB,KAAKC,eAAe,EAAE;;;QAI7F,MAAMnG,KAAK,GAAG4D,cAAc,CAACuC,eAAe,CAACvF,YAAY,EAAEC,SAAS,CAAClB,QAAQ,EAAE,IAAI,CAAC;QACpF,IAAIK,KAAK,EAAE;UACT,MAAM4I,iBAAiB,GAAG9E,gBAAgB,CAACqC,eAAe,CAACjF,cAAc,CAAC+C,SAAS,CAAC;UACpF,IAAI2E,iBAAiB,EAAE;YACrB,IAAI,CAAClD,mBAAmB,CAACmD,WAAW,CAACD,iBAAiB,CAAC;YACvD,MAAMT,SAAS,CAACjC,gBAAgB,CAAChF,cAAc,EAAE0H,iBAAiB,CAAC;YACnE,IAAI,CAAClD,mBAAmB,CAACoD,WAAW,CAACF,iBAAiB,CAAC;UACxD;QACF,OAAM;UACL,MAAMT,SAAS,CAACjC,gBAAgB,CAAChF,cAAc,EAAEzB,SAAS,CAAC;QAC5D;MACF,OAAM;QACL,MAAM0I,SAAS,CAACjC,gBAAgB,CAAChF,cAAc,EAAEiF,eAAe,KAAf,QAAAA,eAAe,KAAf,kBAAAA,eAAe,CAAEjF,cAAc,CAAC;QACjF,IAAIiF,eAAe,IAAIA,eAAe,CAACjF,cAAc,IAAI,CAACgH,iBAAiB,EAAE;UAC3E/B,eAAe,CAACjF,cAAc,CAAC0D,SAAS,CAACgC,GAAG,CAAC,iBAAiB,CAAC;UAC/DT,eAAe,CAACjF,cAAc,CAAC2F,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;QACnE;MACF;IACF;;EAGH7H,MAAMA,CAAA;IACJ,MAAM;MAAE+C;IAAQ,CAAE,GAAG,IAAI,CAACzC,KAAK;IAC/B,MAAMoC,eAAe,GAAG5C,KAAK,CAAC+C,QAAQ,CAACkH,IAAI,CAAChH,QAAQ,CAAuB;IAC3E,IAAI,CAACL,eAAe,GAAGA,eAAe;IAEtC,MAAMsH,UAAU,GAAG,IAAI,CAACjD,OAAO,CAACtF,mBAAmB,CAAC,IAAI,CAACO,EAAE,EAAE,IAAI,CAACU,eAAe,EAAE,IAAI,CAACpC,KAAK,CAACuB,SAAS,EAAE,MAAK;MAC5G,IAAI,CAACiG,WAAW,EAAE;IACpB,CAAC,CAAC;IAEF,OACEhI,KAAC,CAAAG,aAAA,CAAAgK,YAAY,CAACC,QAAQ;MAACC,KAAK,EAAE,IAAI,CAACpE;IAAiB,CACjD,EAAAjG,KAAK,CAAC4D,YAAY,CACjBhB,eAAsB,EACtB;MACE0H,GAAG,EAAGvF,IAAgC,IAAI;QACxC,IAAInC,eAAe,CAACpC,KAAK,CAAC+J,MAAM,EAAE;UAChC3H,eAAe,CAACpC,KAAK,CAAC+J,MAAM,CAACxF,IAAI,CAAC;QACnC;QACD,IAAInC,eAAe,CAACpC,KAAK,CAACgK,YAAY,EAAE;UACtC5H,eAAe,CAACpC,KAAK,CAACgK,YAAY,CAACC,OAAO,GAAG1F,IAAI;QAClD;QACD,IAAI,CAAC6B,mBAAmB,GAAG7B,IAAI;QAC/B,MAAM;UAAEuF;QAAG,CAAE,GAAG1H,eAAsB;QACtC,IAAI,OAAO0H,GAAG,KAAK,UAAU,EAAE;UAC7BA,GAAG,CAACvF,IAAI,CAAC;QACV;;IAEJ,GACDmF,UAAU,CACX,CACqB;;EAI5B,WAAWQ,WAAWA,CAAA;IACpB,OAAOC,mBAAmB;;AAE7B;AAID,SAAS/C,UAAUA,CAAC7C,IAAqB,EAAEhD,SAAoB;EAC7D,IAAI6I,WAA4B;EAChC5K,KAAK,CAAC+C,QAAQ,CAACC,OAAO,CAAC+B,IAA0B,EAAG7B,KAAyB,IAAI;IAC/E,MAAMhC,KAAK,GAAGN,SAAS,CAAC;MACtBC,QAAQ,EAAEkB,SAAS,CAAClB,QAAQ;MAC5BC,cAAc,EAAEoC,KAAK,CAAC1C;IACvB,EAAC;IACF,IAAIU,KAAK,EAAE;MACT0J,WAAW,GAAG1H,KAAK;IACpB;EACH,CAAC,CAAC;EAEF,IAAI0H,WAAW,EAAE;IACf,OAAOA,WAAW;EACnB;;;EAGD5K,KAAK,CAAC+C,QAAQ,CAACC,OAAO,CAAC+B,IAA0B,EAAG7B,KAAyB,IAAI;IAC/E,IAAI,EAAEA,KAAK,CAAC1C,KAAK,CAACD,IAAI,IAAI2C,KAAK,CAAC1C,KAAK,CAACQ,IAAI,CAAC,EAAE;MAC3C4J,WAAW,GAAG1H,KAAK;IACpB;EACH,CAAC,CAAC;EAEF,OAAO0H,WAAW;AACpB;AAEA,SAAS9F,cAAcA,CAACC,IAAwB,EAAElE,QAAgB,EAAEgK,UAAoB;EACtF,OAAOjK,SAAS,CAAC;IACfC,QAAQ;IACRC,cAAc,EAAAT,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACTyE,IAAI,CAACvE,KAAK;MACbC,KAAK,EAAEoK;IAAU,CAClB;EACF,EAAC;AACJ;ACnbA,MAAMC,cAAe,SAAQ9K,KAAK,CAACC,aAA2C;EAmB5EqB,YAAYd,KAAoB;IAC9B,KAAK,CAACA,KAAK,CAAC;IAlBd,IAA+B,CAAAuK,+BAAA,GAAmD,EAAE;IAEpF,KAAAC,eAAe,GAAG,IAAIC,eAAe,EAAE;IACvC,KAAA/G,SAAS,GAAG,IAAI9C,oBAAoB,EAAE;IACtC,KAAA8J,uBAAuB,GAA6B;MAClDC,SAAS,EAAEA,CAAA,KAAM,IAAI,CAACH,eAAe,CAACG,SAAS,EAAE;MACjDjE,WAAW,EAAE,IAAI,CAAChD,SAAS,CAACkH,KAAK;MACjCxJ,sBAAsB,EAAE,IAAI,CAACsC,SAAS,CAACtC,sBAAsB;MAC7DD,mBAAmB,EAAE,IAAI,CAACuC,SAAS,CAACvC,mBAAmB;MACvDsH,MAAM,EAAEA,CAAA,KAAM,IAAI,CAACoC,kBAAkB,EAAE;MACvC9J,cAAc,EAAE,IAAI,CAAC2C,SAAS,CAAC3C,cAAc;MAC7CE,uBAAuB,EAAE,IAAI,CAACyC,SAAS,CAACzC,uBAAuB;MAC/DC,8BAA8B,EAAE,IAAI,CAACwC,SAAS,CAACxC,8BAA8B;MAC7EmG,WAAW,EAAE,IAAI,CAAC3D,SAAS,CAAC4D,GAAG;MAC/BwD,eAAe,EAAE,IAAI,CAACpH,SAAS,CAACP;KACjC;IAKC,MAAM5B,SAAS,GAAG;MAChBG,EAAE,EAAEC,UAAU,CAAC,WAAW,CAAC;MAC3BtB,QAAQ,EAAE,IAAI,CAACL,KAAK,CAAC+K,QAAQ,CAAC1K,QAAQ;MACtC2K,MAAM,EAAE,IAAI,CAAChL,KAAK,CAAC+K,QAAQ,CAACC;KAC7B;IAED,IAAI,CAACR,eAAe,CAAClD,GAAG,CAAC/F,SAAS,CAAC;IACnC,IAAI,CAAC0J,eAAe,GAAG,IAAI,CAACA,eAAe,CAACjK,IAAI,CAAC,IAAI,CAAC;IACtD,IAAI,CAACkK,cAAc,GAAG,IAAI,CAACA,cAAc,CAAClK,IAAI,CAAC,IAAI,CAAC;IACpD,IAAI,CAACmK,gBAAgB,GAAG,IAAI,CAACA,gBAAgB,CAACnK,IAAI,CAAC,IAAI,CAAC;IACxD,IAAI,CAACoK,cAAc,GAAG,IAAI,CAACA,cAAc,CAACpK,IAAI,CAAC,IAAI,CAAC;IACpD,IAAI,CAAC6J,kBAAkB,GAAG,IAAI,CAACA,kBAAkB,CAAC7J,IAAI,CAAC,IAAI,CAAC;IAC5D,IAAI,CAAChB,KAAK,CAACqL,uBAAuB,CAAC,IAAI,CAACC,mBAAmB,CAACtK,IAAI,CAAC,IAAI,CAAC,CAAC;IACvE,IAAI,CAACuK,mBAAmB,GAAG,IAAI,CAACA,mBAAmB,CAACvK,IAAI,CAAC,IAAI,CAAC;IAE9D,IAAI,CAACwK,KAAK,GAAG;MACXjK;KACD;;EAGH0J,eAAeA,CAACQ,GAAW,EAAE1L,IAAa,EAAEkH,YAAkB;IAC5D,IAAI,CAAClH,IAAI,EAAE;MACT;IACD;IAED,MAAMwB,SAAS,GAAG,IAAI,CAACiJ,eAAe,CAACkB,yBAAyB,CAACD,GAAG,CAAC;IACrE,MAAM,CAACpL,QAAQ,EAAE2K,MAAM,CAAC,GAAGjL,IAAI,CAAC4L,KAAK,CAAC,GAAG,CAAC;IAC1C,IAAIpK,SAAS,EAAE;MACb,IAAI,CAACqK,mBAAmB,GAAQ/L,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAAyB,SAAS,CAAE;QAAAwF,WAAW,EAAE,MAAM;QAAEC,cAAc,EAAE;MAAM,EAAE;MACxF,IAAIzF,SAAS,CAAClB,QAAQ,KAAKA,QAAQ,EAAE;QACnC,IAAI,CAACuL,mBAAmB,CAAC3E,YAAY,GAAGA,YAAY;QACpD,IAAI,CAACjH,KAAK,CAAC6L,OAAO,CAACC,IAAI,CAACvK,SAAS,CAAClB,QAAQ,IAAIkB,SAAS,CAACyJ,MAAM,IAAI,EAAE,CAAC,CAAC;MACvE,OAAM;QACL,IAAI,CAACY,mBAAmB,CAACvL,QAAQ,GAAGA,QAAQ;QAC5C,IAAI,CAACuL,mBAAmB,CAACZ,MAAM,GAAGA,MAAM,GAAG,GAAG,GAAGA,MAAM,GAAG7K,SAAS;QACnE,IAAI,CAACyL,mBAAmB,CAAC3E,YAAY,GAAGA,YAAY;QACpD,IAAI,CAACjH,KAAK,CAAC6L,OAAO,CAACC,IAAI,CAACzL,QAAQ,IAAI2K,MAAM,GAAG,GAAG,GAAGA,MAAM,GAAG,EAAE,CAAC,CAAC;MACjE;IACF,OAAM;MACL,IAAI,CAACI,cAAc,CAAC/K,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAEF,SAAS,EAAE8G,YAAY,EAAEwE,GAAG,CAAC;IAC5E;;EAGHH,mBAAmBA,CAACP,QAAwC,EAAEgB,MAAqB;;IACjF,IAAIC,mBAA8B;IAClC,IAAI,IAAI,CAACJ,mBAAmB,EAAE;MAC5B,IAAI,IAAI,CAACA,mBAAmB,CAAC7E,WAAW,KAAK,SAAS,EAAE;QACtDiF,mBAAmB,GAAG,IAAI,CAACxB,eAAe,CAACyB,QAAQ,EAAE;MACtD,OAAM;QACLD,mBAAmB,GAAG,IAAI,CAACxB,eAAe,CAACP,OAAO,EAAE;MACrD;IACF,OAAM;MACL+B,mBAAmB,GAAG,IAAI,CAACxB,eAAe,CAACP,OAAO,EAAE;IACrD;IAED,MAAMiC,UAAU,GAAGF,mBAAmB,CAAC3L,QAAQ,GAAG2L,mBAAmB,CAAChB,MAAM;IAC5E,IAAIkB,UAAU,KAAKnB,QAAQ,CAAC1K,QAAQ,EAAE;MACpC,IAAI,CAAC,IAAI,CAACuL,mBAAmB,EAAE;QAC7B,IAAIG,MAAM,KAAK,SAAS,EAAE;UACxB,IAAI,CAACH,mBAAmB,GAAG;YACzB7E,WAAW,EAAE,SAAS;YACtBC,cAAc,EAAE,MAAM;YACtByE,GAAG,EAAE,IAAI,CAACU;WACX;QACF;QACD,IAAIJ,MAAM,KAAK,KAAK,EAAE;UACpB,MAAMK,YAAY,GAAG,IAAI,CAAC5B,eAAe,CAACP,OAAO,EAAE;UACnD,IAAImC,YAAY,IAAIA,YAAY,CAACjE,aAAa,EAAE;YAC9C,MAAMkE,QAAQ,GAAG,IAAI,CAAC7B,eAAe,CAAC8B,gBAAgB,CAACF,YAAY,CAAC;YACpE,IAAI,CAACR,mBAAmB,GAAQ/L,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAAuM,QAAQ,CAAE;cAAAtF,WAAW,EAAE,KAAK;cAAEC,cAAc,EAAE;YAAM,EAAE;UACvF,OAAM;YACL,IAAI,CAAC4E,mBAAmB,GAAG;cACzB7E,WAAW,EAAE,KAAK;cAClBC,cAAc,EAAE,MAAM;cACtByE,GAAG,EAAE,IAAI,CAACU;aACX;UACF;QACF;QACD,IAAI,CAAC,IAAI,CAACP,mBAAmB,EAAE;UAC7B,IAAI,CAACA,mBAAmB,GAAG;YACzB7E,WAAW,EAAE,MAAM;YACnBC,cAAc,EAAE,EAAA7C,EAAA,GAAA4G,QAAQ,CAACS,KAAK,cAAArH,EAAA,uBAAAA,EAAA,CAAEwE,SAAS,KAAI,SAAS;YACtD1B,YAAY,EAAE,CAAA/C,EAAA,GAAA6G,QAAQ,CAACS,KAAK,cAAAtH,EAAA,uBAAAA,EAAA,CAAEqI,aAAa;YAC3Cd,GAAG,EAAE,IAAI,CAACU;WACX;QACF;MACF;MAED,IAAI5K,SAAoB;MAExB,IAAI,CAAAiL,EAAA,OAAI,CAACZ,mBAAmB,cAAAY,EAAA,uBAAAA,EAAA,CAAE9K,EAAE,EAAE;QAChCH,SAAS,GAAA1B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACH,IAAI,CAAC8L,mBAAiC;UAC1CnI,YAAY,EAAEuI,mBAAmB,CAAC3L;QAAQ,EAC3C;QACD,IAAI,CAACmK,eAAe,CAAClD,GAAG,CAAC/F,SAAS,CAAC;MACpC,OAAM;QACL,MAAMkL,QAAQ,GACZ,IAAI,CAACb,mBAAmB,CAAC7E,WAAW,KAAK,MAAM,IAAI,IAAI,CAAC6E,mBAAmB,CAAC5E,cAAc,KAAK,SAAS;QAC1GzF,SAAS,GAAA1B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA;UACP4B,EAAE,EAAEC,UAAU,CAAC,WAAW;QAAC,GACxB,IAAI,CAACiK,mBAAmB,CAC3B;UAAAnI,YAAY,EAAEuI,mBAAmB,CAAC3L,QAAQ;UAC1CA,QAAQ,EAAE0K,QAAQ,CAAC1K,QAAQ;UAC3B2K,MAAM,EAAED,QAAQ,CAACC,MAAM;UACvB3G,MAAM,EAAE,IAAI,CAACrE,KAAK,CAACU,KAAK,CAAC2D,MAAM;UAC/ByC,qBAAqB,EAAEkF,mBAAmB,CAACvI;QAAY,EACxD;QACD,IAAIgJ,QAAQ,EAAE;UACZlL,SAAS,CAACkK,GAAG,GAAGO,mBAAmB,CAACP,GAAG;UACvClK,SAAS,CAAC4G,aAAa,GAAG6D,mBAAmB,CAAC3L,QAAQ;QACvD,OAAM,IAAIkB,SAAS,CAACwF,WAAW,KAAK,KAAK,EAAE;UAC1C,MAAM2F,CAAC,GAAG,IAAI,CAAClC,eAAe,CAAC8B,gBAAgB,CAAC/K,SAAS,CAAC;UAC1DA,SAAS,CAAC4G,aAAa,GAAGuE,CAAC,aAADA,CAAC,KAAD,kBAAAA,CAAC,CAAEvE,aAAa;QAC3C,OAAM,IAAI5G,SAAS,CAACwF,WAAW,KAAK,MAAM,IAAIxF,SAAS,CAACkK,GAAG,KAAKO,mBAAmB,CAACP,GAAG,EAAE;;UAExF,MAAMkB,SAAS,GAAG,IAAI,CAACnC,eAAe,CAACkB,yBAAyB,CAACnK,SAAS,CAACkK,GAAG,CAAC;UAC/ElK,SAAS,CAAC4G,aAAa,GAAGwE,SAAS,aAATA,SAAS,KAAT,kBAAAA,SAAS,CAAExE,aAAa;QACnD,OAAM,IAAI5G,SAAS,CAACwF,WAAW,KAAK,SAAS,EAAE;;UAE9C,MAAM6F,gBAAgB,GAAG,IAAI,CAACpC,eAAe,CAACP,OAAO,EAAE;UAEvD;;;;AAIG;UACH,MAAM4C,eAAe,GAAGD,gBAAgB,aAAhBA,gBAAgB,KAAhB,kBAAAA,gBAAgB,CAAEzE,aAAa;UACvD,MAAMA,aAAa,GACjB0E,eAAe,KAAK1M,SAAS,IAAI0M,eAAe,KAAKtL,SAAS,CAAClB,QAAQ,GACnEwM,eAAe,GACftL,SAAS,CAAC4G,aAAa;UAE7B5G,SAAS,CAACkC,YAAY,GAAG,CAAAmJ,gBAAgB,KAAhB,QAAAA,gBAAgB,KAAhB,kBAAAA,gBAAgB,CAAEvM,QAAQ,KAAIkB,SAAS,CAACkC,YAAY;UAC7ElC,SAAS,CAACuF,qBAAqB,GAAG8F,gBAAgB,aAAhBA,gBAAgB,KAAhB,kBAAAA,gBAAgB,CAAEnJ,YAAY;UAChElC,SAAS,CAAC4G,aAAa,GAAGA,aAAa;UAEvC;;;;;AAKG;UACH5G,SAAS,CAACyF,cAAc,GAAGzF,SAAS,CAACyF,cAAc,KAAI4F,gBAAgB,aAAhBA,gBAAgB,KAAhB,kBAAAA,gBAAgB,CAAE5F,cAAc;UACvFzF,SAAS,CAAC6H,cAAc,GAAG7H,SAAS,CAAC6H,cAAc,KAAIwD,gBAAgB,aAAhBA,gBAAgB,KAAhB,kBAAAA,gBAAgB,CAAExD,cAAc;QACxF;QAED,IAAI,CAACoB,eAAe,CAAClD,GAAG,CAAC/F,SAAS,CAAC;MACpC;MAED,IAAI,CAACuL,QAAQ,CAAC;QACZvL;MACD,EAAC;IACH;IAED,IAAI,CAACqK,mBAAmB,GAAGzL,SAAS;;EAGtC;;;;;AAKG;EACHgL,gBAAgBA,CAAA;IACd,MAAMU,OAAO,GAAG,IAAI,CAAC7L,KAAK,CAAC6L,OAAc;IACzC,MAAMpD,MAAM,GAAGoD,OAAO,CAACpD,MAAM,IAAIoD,OAAO,CAACkB,IAAI;IAC7CtE,MAAM,EAAE;;EAGV2C,cAAcA,CACZrL,IAAY,EACZgH,WAAwB,EACxBC,cAAgC,EAChCoC,cAAiC,EACjCnC,YAAkB,EAClBwE,GAAY;IAEZ,IAAI,CAACG,mBAAmB,GAAG/L,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC8L,mBAAmB,IAAI,EAAE,EAAE;MACvE7E,WAAW;MACXC,cAAc;MACdC,YAAY;MACZmC,cAAc;MACdqC;IACD,EAAC;IAEF,IAAI1E,WAAW,KAAK,MAAM,EAAE;MAC1B,IAAI,CAAC/G,KAAK,CAAC6L,OAAO,CAACC,IAAI,CAAC/L,IAAI,CAAC;IAC9B,OAAM;MACL,IAAI,CAACC,KAAK,CAAC6L,OAAO,CAACmB,OAAO,CAACjN,IAAI,CAAC;IACjC;;EAGH8K,kBAAkBA,CAACoC,WAAA,GAAkC,GAAG,EAAE7D,cAAiC;IACzF,MAAMvB,MAAM,GAAGC,SAAS,EAAE;IAC1BmF,WAAW,GAAGA,WAAW,GAAGA,WAAW,GAAGpF,MAAM,IAAIA,MAAM,CAACG,GAAG,CAAC,uBAA8B,CAAC;IAC9F,MAAMzG,SAAS,GAAG,IAAI,CAACiJ,eAAe,CAACP,OAAO,EAAE;IAChD,IAAI1I,SAAS,IAAIA,SAAS,CAAC4G,aAAa,EAAE;MACxC,MAAMkE,QAAQ,GAAG,IAAI,CAAC7B,eAAe,CAAC8B,gBAAgB,CAAC/K,SAAS,CAAC;MACjE,IAAI8K,QAAQ,EAAE;QACZ;;;;AAIG;QACH,MAAMa,iBAAiB,GAAG9D,cAAc,IAAI7H,SAAS,CAAC6H,cAAc;QACpE,IAAI,CAACwC,mBAAmB,GAAA/L,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACnBuM,QAAQ;UACXtF,WAAW,EAAE,KAAK;UAClBC,cAAc,EAAE,MAAM;UACtBoC,cAAc,EAAE8D;QAAiB,EAClC;QACD,IACE3L,SAAS,CAACkC,YAAY,KAAKlC,SAAS,CAAC4G,aAAa;QAClD;;;;;AAKG;QACFkE,QAAQ,CAAChM,QAAQ,KAAKkB,SAAS,CAAC4G,aAAa,IAAI5G,SAAS,CAACkK,GAAG,KAAK,EAAE,IAAIY,QAAQ,CAACZ,GAAG,KAAK,EAAE,CAAC,EAC9F;UACA;;;;;AAKG;UACH,MAAMI,OAAO,GAAG,IAAI,CAAC7L,KAAK,CAAC6L,OAAc;UACzC,MAAMpD,MAAM,GAAGoD,OAAO,CAACpD,MAAM,IAAIoD,OAAO,CAACkB,IAAI;UAC7CtE,MAAM,EAAE;QACT,OAAM;UACL,IAAI,CAAC2C,cAAc,CAACiB,QAAQ,CAAChM,QAAQ,IAAIgM,QAAQ,CAACrB,MAAM,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAEkC,iBAAiB,CAAC;QACnG;MACF,OAAM;QACL,IAAI,CAAC9B,cAAc,CAAC6B,WAAqB,EAAE,KAAK,EAAE,MAAM,EAAE7D,cAAc,CAAC;MAC1E;IACF,OAAM;MACL,IAAI,CAACgC,cAAc,CAAC6B,WAAqB,EAAE,KAAK,EAAE,MAAM,EAAE7D,cAAc,CAAC;IAC1E;;EAGH8B,cAAcA,CAACO,GAAW,EAAE0B,YAAoB,EAAEC,oBAAyB;IACzE,MAAM7L,SAAS,GAAG,IAAI,CAACiJ,eAAe,CAAC6C,uBAAuB,CAAC5B,GAAG,CAAC;IACnE,IAAIlK,SAAS,EAAE;MACb,MAAM+L,YAAY,GAAAzN,MAAA,CAAAC,MAAA,KAAQyB,SAAS,CAAE;MACrC+L,YAAY,CAACjN,QAAQ,GAAG8M,YAAY;MACpCG,YAAY,CAACrG,YAAY,GAAGmG,oBAAoB;MAChD,IAAI,CAACxB,mBAAmB,GAAQ/L,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAAwN,YAAY,CAAE;QAAAvG,WAAW,EAAE,KAAK;QAAEC,cAAc,EAAE;MAAM,EAAE;MAC1F,IAAI,CAAChH,KAAK,CAAC6L,OAAO,CAACC,IAAI,CAACwB,YAAY,CAACjN,QAAQ,IAAIiN,YAAY,CAACtC,MAAM,IAAI,EAAE,CAAC,CAAC;IAC7E;;EAGHO,mBAAmBA,CAACE,GAAW;IAC7B,IAAI,CAACU,UAAU,GAAGV,GAAG;IACrB,MAAM8B,EAAE,GAAA1N,MAAA,CAAAC,MAAA,KAAQ,IAAI,CAAC0K,eAAe,CAACP,OAAO,EAAE,CAAE;IAChD,IAAIsD,EAAE,CAAC9B,GAAG,KAAKA,GAAG,EAAE;MAClB8B,EAAE,CAAC9B,GAAG,GAAGA,GAAG;MACZ,IAAI,CAACjB,eAAe,CAACgD,MAAM,CAACD,EAAE,CAAC;IAChC;;EAGH7N,MAAMA,CAAA;IACJ,OACEF,KAAC,CAAAG,aAAA,CAAAwK,mBAAmB,CAACP,QAAQ;MAACC,KAAK,EAAE,IAAI,CAACa;IAAuB,GAC/DlL,KAAA,CAAAG,aAAA,CAAC8N,UAAU;MACT3L,QAAQ,EAAEvC,aAAa;MACvBmO,WAAW,EAAE,EAAE;MACfC,YAAY,EAAEnI,YAAY;MAC1BjE,SAAS,EAAE,IAAI,CAACiK,KAAK,CAACjK,SAAU;MAChCqM,YAAY,EAAE,IAAI,CAACzC,gBAAgB;MACnC0C,cAAc,EAAE,IAAI,CAAChD,kBAAkB;MACvCiD,UAAU,EAAE,IAAI,CAAC1C,cAAc;MAC/B2C,eAAe,EAAE,IAAI,CAACxC,mBAAmB;MACzCyC,WAAW,EAAE,IAAI,CAAC/C,eAAe;MACjCgD,UAAU,EAAE,IAAI,CAAC/C,cAAc;MAC/BV,eAAe,EAAE,IAAI,CAACA;IAAe,GAEpC,IAAI,CAACxK,KAAK,CAACyC,QAAQ,CACT,CACgB;;AAGpC;AAEM,MAAMyL,SAAS,GAAGC,UAAU,CAAC7D,cAAc,CAAC;AACnD4D,SAAS,CAACE,WAAW,GAAG,WAAW;ACvUtB,MAAAC,cAAe,SAAQ7O,KAAK,CAAC8O,SAA8B;EAItExN,YAAYd,KAA0B;IACpC,KAAK,CAACA,KAAK,CAAC;IACZ,MAAM;QAAE6L;MAAO,IAAc7L,KAAK;MAAduO,IAAI,GAAAC,MAAA,CAAKxO,KAAK,EAA5B,CAAoB,WAAQ;IAClC,IAAI,CAAC6L,OAAO,GAAGA,OAAO,IAAI4C,oBAAa,CAACF,IAAI,CAAC;IAC7C,IAAI,CAAC1C,OAAO,CAAC6C,MAAM,CAAC,IAAI,CAACpD,mBAAmB,CAACtK,IAAI,CAAC,IAAI,CAAC,CAAC;IACxD,IAAI,CAACqK,uBAAuB,GAAG,IAAI,CAACA,uBAAuB,CAACrK,IAAI,CAAC,IAAI,CAAC;;EAGxE;;;;;;;AAOG;EACHsK,mBAAmBA,CAACP,QAAyB,EAAEgB,MAAqB;IAClE,MAAM4C,aAAa,GAAI5D,QAAgB,CAACA,QAAQ,IAAIA,QAAQ;IAC5D,MAAM6D,WAAW,GAAI7D,QAAgB,CAACgB,MAAM,IAAIA,MAAM;IACtD,IAAI,IAAI,CAAC8C,oBAAoB,EAAE;MAC7B,IAAI,CAACA,oBAAoB,CAACF,aAAa,EAAEC,WAAW,CAAC;IACtD;;EAGHvD,uBAAuBA,CAACyD,EAA8D;IACpF,IAAI,CAACD,oBAAoB,GAAGC,EAAE;;EAGhCpP,MAAMA,CAAA;IACJ,MAAMyE,EAAyB,OAAI,CAACnE,KAAK;MAAnC;QAAEyC;MAAQ,IAAA0B,EAAyB;MAApBnE,KAAK,GAApBwO,MAAA,CAAArK,EAAA,cAAsB,CAAa;IACzC,OACE3E,KAAC,CAAAG,aAAA,CAAAoP,MAAM,EAAClP,MAAA,CAAAC,MAAA;MAAA+L,OAAO,EAAE,IAAI,CAACA;IAAO,GAAM7L,KAAK,GACtCR,KAAA,CAAAG,aAAA,CAACuO,SAAS;MAAC7C,uBAAuB,EAAE,IAAI,CAACA;IAAuB,GAAG5I,QAAQ,CAAa,CACjF;;AAGd;ACzCY,MAAAuM,oBAAqB,SAAQxP,KAAK,CAAC8O,SAAoC;EAIlFxN,YAAYd,KAAgC;IAC1C,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAAC6L,OAAO,GAAG7L,KAAK,CAAC6L,OAAO;IAC5B,IAAI,CAACA,OAAO,CAAC6C,MAAM,CAAC,IAAI,CAACpD,mBAAmB,CAACtK,IAAI,CAAC,IAAI,CAAC,CAAC;IACxD,IAAI,CAACqK,uBAAuB,GAAG,IAAI,CAACA,uBAAuB,CAACrK,IAAI,CAAC,IAAI,CAAC;;EAGxE;;;;;;;AAOG;EACHsK,mBAAmBA,CAACP,QAAyB,EAAEgB,MAAqB;IAClE,MAAM4C,aAAa,GAAI5D,QAAgB,CAACA,QAAQ,IAAIA,QAAQ;IAC5D,MAAM6D,WAAW,GAAI7D,QAAgB,CAACgB,MAAM,IAAIA,MAAM;IACtD,IAAI,IAAI,CAAC8C,oBAAoB,EAAE;MAC7B,IAAI,CAACA,oBAAoB,CAACF,aAAa,EAAEC,WAAW,CAAC;IACtD;;EAGHvD,uBAAuBA,CAACyD,EAA8D;IACpF,IAAI,CAACD,oBAAoB,GAAGC,EAAE;;EAGhCpP,MAAMA,CAAA;IACJ,MAAMyE,EAAyB,OAAI,CAACnE,KAAK;MAAnC;QAAEyC;MAAQ,IAAA0B,EAAyB;MAApBnE,KAAK,GAApBwO,MAAA,CAAArK,EAAA,cAAsB,CAAa;IACzC,OACE3E,KAAA,CAAAG,aAAA,CAACsP,QAAM,EAAApP,MAAA,CAAAC,MAAA,KAAKE,KAAK,GACfR,KAAA,CAAAG,aAAA,CAACuO,SAAS;MAAC7C,uBAAuB,EAAE,IAAI,CAACA;IAAuB,GAAG5I,QAAQ,CAAa,CACjF;;AAGd;ACtCY,MAAAyM,kBAAmB,SAAQ1P,KAAK,CAAC8O,SAAkC;EAI9ExN,YAAYd,KAA8B;IACxC,KAAK,CAACA,KAAK,CAAC;IACZ,MAAM;QAAE6L;MAAO,IAAc7L,KAAK;MAAduO,IAAI,GAAAC,MAAA,CAAKxO,KAAK,EAA5B,CAAoB,WAAQ;IAClC,IAAI,CAAC6L,OAAO,GAAGA,OAAO,IAAIsD,iBAAa,CAACZ,IAAI,CAAC;IAC7C,IAAI,CAAC1C,OAAO,CAAC6C,MAAM,CAAC,IAAI,CAACpD,mBAAmB,CAACtK,IAAI,CAAC,IAAI,CAAC,CAAC;IACxD,IAAI,CAACqK,uBAAuB,GAAG,IAAI,CAACA,uBAAuB,CAACrK,IAAI,CAAC,IAAI,CAAC;;EAGxE;;;;;;;AAOG;EACHsK,mBAAmBA,CAACP,QAAyB,EAAEgB,MAAqB;IAClE,MAAM4C,aAAa,GAAI5D,QAAgB,CAACA,QAAQ,IAAIA,QAAQ;IAC5D,MAAM6D,WAAW,GAAI7D,QAAgB,CAACgB,MAAM,IAAIA,MAAM;IACtD,IAAI,IAAI,CAAC8C,oBAAoB,EAAE;MAC7B,IAAI,CAACA,oBAAoB,CAACF,aAAa,EAAEC,WAAW,CAAC;IACtD;;EAGHvD,uBAAuBA,CAACyD,EAA8D;IACpF,IAAI,CAACD,oBAAoB,GAAGC,EAAE;;EAGhCpP,MAAMA,CAAA;IACJ,MAAMyE,EAAyB,OAAI,CAACnE,KAAK;MAAnC;QAAEyC;MAAQ,IAAA0B,EAAyB;MAApBnE,KAAK,GAApBwO,MAAA,CAAArK,EAAA,cAAsB,CAAa;IACzC,OACE3E,KAAC,CAAAG,aAAA,CAAAoP,MAAM,EAAClP,MAAA,CAAAC,MAAA;MAAA+L,OAAO,EAAE,IAAI,CAACA;IAAO,GAAM7L,KAAK,GACtCR,KAAA,CAAAG,aAAA,CAACuO,SAAS;MAAC7C,uBAAuB,EAAE,IAAI,CAACA;IAAuB,GAAG5I,QAAQ,CAAa,CACjF;;AAGd"},"metadata":{},"sourceType":"module","externalDependencies":[]}